import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactNode } from 'react';
import {
  use{{pascalCase name}}ListQuery,
  use{{pascalCase name}}ByIdQuery,
  use{{pascalCase name}}InfiniteQuery,
  use{{pascalCase name}}SearchQuery,
  use{{pascalCase name}}StatisticsQuery,
  useCreate{{pascalCase name}}Mutation,
  useUpdate{{pascalCase name}}Mutation,
  useDelete{{pascalCase name}}Mutation,
  {{camelCase name}}QueryKeys,
  {{camelCase name}}ApiHelpers,
} from './{{camelCase name}}Api';
import type { 
  {{pascalCase name}}Item, 
  {{pascalCase name}}ListData, 
  {{pascalCase name}}Statistics,
  Create{{pascalCase name}}Data,
  Update{{pascalCase name}}Data 
} from './{{camelCase name}}Api.types';

// Mock fetch
global.fetch = jest.fn();
const mockFetch = fetch as jest.MockedFunction<typeof fetch>;

// Test wrapper with QueryClient
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });

  return ({ children }: { children: ReactNode }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
};

// Mock data
const mock{{pascalCase name}}Item: {{pascalCase name}}Item = {
  id: '1',
  name: 'Test {{pascalCase name}}',
  description: 'Test description',
  status: 'active',
  category: 'test-category',
  tags: ['tag1', 'tag2'],
  metadata: { key: 'value' },
  createdAt: '2023-01-01T00:00:00Z',
  updatedAt: '2023-01-01T00:00:00Z',
};

const mock{{pascalCase name}}ListData: {{pascalCase name}}ListData = {
  items: [mock{{pascalCase name}}Item],
  total: 1,
  page: 1,
  limit: 10,
  hasNextPage: false,
  hasPreviousPage: false,
};

const mock{{pascalCase name}}Statistics: {{pascalCase name}}Statistics = {
  total: 100,
  byStatus: { active: 60, inactive: 30, pending: 10 },
  byCategory: { 'test-category': 50, 'other-category': 50 },
  recentActivity: {
    created: 5,
    updated: 10,
    deleted: 2,
    period: 'last_24_hours',
  },
  trends: {
    growth: { daily: 1.5, weekly: 5.2, monthly: 15.8 },
    popular: {
      categories: [{ name: 'test-category', count: 50 }],
      tags: [{ name: 'tag1', count: 30 }],
    },
  },
  performance: {
    averageResponseTime: 120,
    successRate: 99.5,
    errorRate: 0.5,
  },
};

describe('{{pascalCase name}} API Service', () => {
  beforeEach(() => {
    mockFetch.mockClear();
  });

  describe('Query Keys', () => {
    it('should generate correct query keys', () => {
      expect({{camelCase name}}QueryKeys.all).toEqual(['{{camelCase name}}']);
      expect({{camelCase name}}QueryKeys.lists()).toEqual(['{{camelCase name}}', 'list']);
      expect({{camelCase name}}QueryKeys.list({ search: 'test' })).toEqual(['{{camelCase name}}', 'list', { search: 'test' }]);
      expect({{camelCase name}}QueryKeys.details()).toEqual(['{{camelCase name}}', 'detail']);
      expect({{camelCase name}}QueryKeys.detail('1')).toEqual(['{{camelCase name}}', 'detail', '1']);
      expect({{camelCase name}}QueryKeys.infinite()).toEqual(['{{camelCase name}}', 'infinite']);
      expect({{camelCase name}}QueryKeys.statistics()).toEqual(['{{camelCase name}}', 'statistics']);
    });
  });

  describe('use{{pascalCase name}}ListQuery', () => {
    it('should fetch {{camelCase name}} list successfully', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mock{{pascalCase name}}ListData,
      } as Response);

      const { result } = renderHook(() => use{{pascalCase name}}ListQuery(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isSuccess).toBe(true));

      expect(result.current.data).toEqual(mock{{pascalCase name}}ListData);
      expect(mockFetch).toHaveBeenCalledWith('{{apiEndpoint}}', {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
      });
    });

    it('should fetch with query parameters', async () => {
      const params = {
        search: 'test',
        status: 'active',
        page: 2,
        limit: 5,
        sortBy: 'name' as const,
        sortOrder: 'asc' as const,
      };

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mock{{pascalCase name}}ListData,
      } as Response);

      const { result } = renderHook(() => use{{pascalCase name}}ListQuery(params), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isSuccess).toBe(true));

      expect(mockFetch).toHaveBeenCalledWith(
        '{{apiEndpoint}}?search=test&status=active&page=2&limit=5&sortBy=name&sortOrder=asc',
        expect.any(Object)
      );
    });
  });

  describe('use{{pascalCase name}}ByIdQuery', () => {
    it('should fetch single {{camelCase name}} successfully', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mock{{pascalCase name}}Item,
      } as Response);

      const { result } = renderHook(() => use{{pascalCase name}}ByIdQuery('1'), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isSuccess).toBe(true));

      expect(result.current.data).toEqual(mock{{pascalCase name}}Item);
      expect(mockFetch).toHaveBeenCalledWith('{{apiEndpoint}}/1', {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
      });
    });

    it('should be disabled when id is empty', () => {
      const { result } = renderHook(() => use{{pascalCase name}}ByIdQuery(''), {
        wrapper: createWrapper(),
      });

      expect(result.current.fetchStatus).toBe('idle');
      expect(mockFetch).not.toHaveBeenCalled();
    });
  });

  describe('use{{pascalCase name}}InfiniteQuery', () => {
    it('should fetch infinite data successfully', async () => {
      const mockInfiniteData = {
        items: [mock{{pascalCase name}}Item],
        page: 1,
        limit: 10,
        total: 25,
        totalPages: 3,
        hasNextPage: true,
        hasPreviousPage: false,
      };

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockInfiniteData,
      } as Response);

      const { result } = renderHook(() => use{{pascalCase name}}InfiniteQuery(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isSuccess).toBe(true));

      expect(result.current.data?.pages).toHaveLength(1);
      expect(result.current.data?.pages[0]).toEqual(mockInfiniteData);
      expect(result.current.hasNextPage).toBe(true);
    });
  });

  describe('use{{pascalCase name}}SearchQuery', () => {
    it('should search {{camelCase name}}s successfully', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mock{{pascalCase name}}ListData,
      } as Response);

      const searchParams = {
        query: 'test search',
        fields: ['name', 'description'] as const,
        fuzzy: true,
        limit: 20,
      };

      const { result } = renderHook(() => use{{pascalCase name}}SearchQuery(searchParams), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isSuccess).toBe(true));

      expect(mockFetch).toHaveBeenCalledWith(
        '{{apiEndpoint}}/search?q=test%20search&fields=name&fields=description&fuzzy=true&limit=20',
        expect.any(Object)
      );
    });

    it('should be disabled when query is empty', () => {
      const { result } = renderHook(() => 
        use{{pascalCase name}}SearchQuery({ query: '' }), 
        { wrapper: createWrapper() }
      );

      expect(result.current.fetchStatus).toBe('idle');
      expect(mockFetch).not.toHaveBeenCalled();
    });
  });

  describe('use{{pascalCase name}}StatisticsQuery', () => {
    it('should fetch statistics successfully', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mock{{pascalCase name}}Statistics,
      } as Response);

      const { result } = renderHook(() => use{{pascalCase name}}StatisticsQuery(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isSuccess).toBe(true));

      expect(result.current.data).toEqual(mock{{pascalCase name}}Statistics);
      expect(mockFetch).toHaveBeenCalledWith('{{apiEndpoint}}/statistics', {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
      });
    });
  });

  describe('useCreate{{pascalCase name}}Mutation', () => {
    it('should create {{camelCase name}} successfully', async () => {
      const createData: Create{{pascalCase name}}Data = {
        name: 'New {{pascalCase name}}',
        description: 'New description',
        status: 'active',
        category: 'new-category',
        tags: ['new-tag'],
      };

      const created{{pascalCase name}}: {{pascalCase name}}Item = {
        ...mock{{pascalCase name}}Item,
        id: '2',
        ...createData,
      };

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => created{{pascalCase name}},
      } as Response);

      const { result } = renderHook(() => useCreate{{pascalCase name}}Mutation(), {
        wrapper: createWrapper(),
      });

      result.current.mutate(createData);

      await waitFor(() => expect(result.current.isSuccess).toBe(true));

      expect(result.current.data).toEqual(created{{pascalCase name}});
      expect(mockFetch).toHaveBeenCalledWith('{{apiEndpoint}}', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(createData),
      });
    });
  });

  describe('useUpdate{{pascalCase name}}Mutation', () => {
    it('should update {{camelCase name}} successfully', async () => {
      const updateData: Update{{pascalCase name}}Data = {
        id: '1',
        data: {
          name: 'Updated {{pascalCase name}}',
          description: 'Updated description',
        },
      };

      const updated{{pascalCase name}}: {{pascalCase name}}Item = {
        ...mock{{pascalCase name}}Item,
        ...updateData.data,
        updatedAt: '2023-01-02T00:00:00Z',
      };

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => updated{{pascalCase name}},
      } as Response);

      const { result } = renderHook(() => useUpdate{{pascalCase name}}Mutation(), {
        wrapper: createWrapper(),
      });

      result.current.mutate(updateData);

      await waitFor(() => expect(result.current.isSuccess).toBe(true));

      expect(result.current.data).toEqual(updated{{pascalCase name}});
      expect(mockFetch).toHaveBeenCalledWith('{{apiEndpoint}}/1', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updateData.data),
      });
    });
  });

  describe('useDelete{{pascalCase name}}Mutation', () => {
    it('should delete {{camelCase name}} successfully', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({}),
      } as Response);

      const { result } = renderHook(() => useDelete{{pascalCase name}}Mutation(), {
        wrapper: createWrapper(),
      });

      result.current.mutate('1');

      await waitFor(() => expect(result.current.isSuccess).toBe(true));

      expect(mockFetch).toHaveBeenCalledWith('{{apiEndpoint}}/1', {
        method: 'DELETE',
        headers: {},
      });
    });
  });

  describe('Error Handling', () => {
    it('should handle fetch errors properly', async () => {
      const errorResponse = {
        message: 'Server error',
        code: 'SERVER_ERROR',
      };

      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
        json: async () => errorResponse,
      } as Response);

      const { result } = renderHook(() => use{{pascalCase name}}ListQuery(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isError).toBe(true));

      expect(result.current.error).toBeDefined();
      expect(result.current.error?.message).toBe('Server error');
      expect(result.current.error?.status).toBe(500);
    });

    it('should not retry on 4xx errors', async () => {
      mockFetch.mockResolvedValue({
        ok: false,
        status: 404,
        statusText: 'Not Found',
        json: async () => ({ message: 'Not found' }),
      } as Response);

      const { result } = renderHook(() => use{{pascalCase name}}ListQuery(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isError).toBe(true));

      // Should only be called once (no retries for 4xx)
      expect(mockFetch).toHaveBeenCalledTimes(1);
    });
  });

  describe('{{camelCase name}}ApiHelpers', () => {
    let queryClient: QueryClient;

    beforeEach(() => {
      queryClient = new QueryClient({
        defaultOptions: { queries: { retry: false } },
      });
    });

    it('should prefetch next page', () => {
      const prefetchSpy = jest.spyOn(queryClient, 'prefetchQuery');
      
      {{camelCase name}}ApiHelpers.prefetchNext{{pascalCase name}}Page(queryClient, { page: 1 });

      expect(prefetchSpy).toHaveBeenCalledWith({
        queryKey: {{camelCase name}}QueryKeys.list({ page: 2 }),
        queryFn: expect.any(Function),
        staleTime: 5 * 60 * 1000,
      });
    });

    it('should invalidate all queries', () => {
      const invalidateSpy = jest.spyOn(queryClient, 'invalidateQueries');
      
      {{camelCase name}}ApiHelpers.invalidateAll{{pascalCase name}}Queries(queryClient);

      expect(invalidateSpy).toHaveBeenCalledWith({
        queryKey: {{camelCase name}}QueryKeys.all,
      });
    });

    it('should clear all cache', () => {
      const removeSpy = jest.spyOn(queryClient, 'removeQueries');
      
      {{camelCase name}}ApiHelpers.clearAll{{pascalCase name}}Cache(queryClient);

      expect(removeSpy).toHaveBeenCalledWith({
        queryKey: {{camelCase name}}QueryKeys.all,
      });
    });

    it('should get cached item by ID', () => {
      queryClient.setQueryData({{camelCase name}}QueryKeys.detail('1'), mock{{pascalCase name}}Item);

      const cachedItem = {{camelCase name}}ApiHelpers.getCached{{pascalCase name}}ById(queryClient, '1');

      expect(cachedItem).toEqual(mock{{pascalCase name}}Item);
    });

    it('should set cached item', () => {
      {{camelCase name}}ApiHelpers.setCached{{pascalCase name}}(queryClient, mock{{pascalCase name}}Item);

      const cachedItem = queryClient.getQueryData({{camelCase name}}QueryKeys.detail('1'));

      expect(cachedItem).toEqual(mock{{pascalCase name}}Item);
    });
  });
});