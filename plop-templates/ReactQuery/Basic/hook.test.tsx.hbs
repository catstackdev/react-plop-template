import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactNode } from 'react';
import use{{pascalCase name}}Query, { use{{pascalCase name}}ByIdQuery, useSearch{{pascalCase name}}Query, {{camelCase name}}QueryKeys } from './use{{pascalCase name}}Query';
import type { {{pascalCase name}}Data, {{pascalCase name}}Item } from './use{{pascalCase name}}Query.types';

// Mock fetch
global.fetch = jest.fn();
const mockFetch = fetch as jest.MockedFunction<typeof fetch>;

// Test wrapper with QueryClient
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  });

  return ({ children }: { children: ReactNode }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
};

// Mock data
const mock{{pascalCase name}}Item: {{pascalCase name}}Item = {
  id: '1',
  name: 'Test {{pascalCase name}}',
  description: 'Test description',
  status: 'active',
  createdAt: '2023-01-01T00:00:00Z',
  updatedAt: '2023-01-01T00:00:00Z',
};

const mock{{pascalCase name}}Data: {{pascalCase name}}Data = {
  items: [mock{{pascalCase name}}Item],
  total: 1,
  page: 1,
  limit: 10,
  hasNextPage: false,
  hasPreviousPage: false,
};

describe('use{{pascalCase name}}Query', () => {
  beforeEach(() => {
    mockFetch.mockClear();
  });

  describe('{{camelCase name}}QueryKeys', () => {
    it('should generate correct query keys', () => {
      expect({{camelCase name}}QueryKeys.all).toEqual(['{{camelCase name}}']);
      expect({{camelCase name}}QueryKeys.lists()).toEqual(['{{camelCase name}}', 'list']);
      expect({{camelCase name}}QueryKeys.list({ search: 'test' })).toEqual(['{{camelCase name}}', 'list', { search: 'test' }]);
      expect({{camelCase name}}QueryKeys.details()).toEqual(['{{camelCase name}}', 'detail']);
      expect({{camelCase name}}QueryKeys.detail('1')).toEqual(['{{camelCase name}}', 'detail', '1']);
    });
  });

  describe('use{{pascalCase name}}Query hook', () => {
    it('should fetch {{camelCase name}} list successfully', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mock{{pascalCase name}}Data,
      } as Response);

      const { result } = renderHook(() => use{{pascalCase name}}Query(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isSuccess).toBe(true));

      expect(result.current.data).toEqual(mock{{pascalCase name}}Data);
      expect(mockFetch).toHaveBeenCalledWith('{{apiEndpoint}}', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });
    });

    it('should fetch {{camelCase name}} list with search params', async () => {
      const params = { search: 'test', status: 'active', page: 1, limit: 5 };
      
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mock{{pascalCase name}}Data,
      } as Response);

      const { result } = renderHook(() => use{{pascalCase name}}Query(params), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isSuccess).toBe(true));

      expect(mockFetch).toHaveBeenCalledWith(
        '{{apiEndpoint}}?search=test&status=active&page=1&limit=5',
        expect.any(Object)
      );
    });

    it('should handle fetch error', async () => {
      const errorResponse = {
        message: 'Failed to fetch',
        code: 'FETCH_ERROR',
      };

      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
        json: async () => errorResponse,
      } as Response);

      const { result } = renderHook(() => use{{pascalCase name}}Query(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isError).toBe(true));

      expect(result.current.error).toBeDefined();
      expect(result.current.error?.message).toBe('Failed to fetch');
    });

    it('should not retry on 4xx errors', async () => {
      mockFetch.mockResolvedValue({
        ok: false,
        status: 404,
        statusText: 'Not Found',
        json: async () => ({ message: 'Not found' }),
      } as Response);

      const { result } = renderHook(() => use{{pascalCase name}}Query(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isError).toBe(true));

      // Should only be called once (no retries for 4xx)
      expect(mockFetch).toHaveBeenCalledTimes(1);
    });
  });

  describe('use{{pascalCase name}}ByIdQuery hook', () => {
    it('should fetch single {{camelCase name}} successfully', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mock{{pascalCase name}}Item,
      } as Response);

      const { result } = renderHook(() => use{{pascalCase name}}ByIdQuery('1'), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isSuccess).toBe(true));

      expect(result.current.data).toEqual(mock{{pascalCase name}}Item);
      expect(mockFetch).toHaveBeenCalledWith('{{apiEndpoint}}/1', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });
    });

    it('should be disabled when id is empty', () => {
      const { result } = renderHook(() => use{{pascalCase name}}ByIdQuery(''), {
        wrapper: createWrapper(),
      });

      expect(result.current.fetchStatus).toBe('idle');
      expect(mockFetch).not.toHaveBeenCalled();
    });
  });

  describe('useSearch{{pascalCase name}}Query hook', () => {
    it('should search {{camelCase name}} with search term', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mock{{pascalCase name}}Data,
      } as Response);

      const { result } = renderHook(() => useSearch{{pascalCase name}}Query('test search'), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isSuccess).toBe(true));

      expect(mockFetch).toHaveBeenCalledWith(
        '{{apiEndpoint}}?search=test%20search',
        expect.any(Object)
      );
    });

    it('should be disabled when search term is empty', () => {
      const { result } = renderHook(() => useSearch{{pascalCase name}}Query(''), {
        wrapper: createWrapper(),
      });

      expect(result.current.fetchStatus).toBe('idle');
      expect(mockFetch).not.toHaveBeenCalled();
    });

    it('should be disabled when search term is only whitespace', () => {
      const { result } = renderHook(() => useSearch{{pascalCase name}}Query('   '), {
        wrapper: createWrapper(),
      });

      expect(result.current.fetchStatus).toBe('idle');
      expect(mockFetch).not.toHaveBeenCalled();
    });
  });
});